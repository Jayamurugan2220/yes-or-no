<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Results ‚Äî My Questions</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    .results-container { max-width: 600px; margin: 0 auto; }
    .result-card { 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
      padding: 16px; 
      margin: 12px 0; 
      border-radius: 12px; 
      color: white; 
    }
    .result-header { font-weight: bold; font-size: 16px; margin-bottom: 10px; }
    .result-question { font-size: 14px; margin: 8px 0; opacity: 0.95; }
    .result-stats { display: flex; gap: 16px; margin-top: 12px; }
    .stat { flex: 1; text-align: center; }
    .stat-value { font-size: 24px; font-weight: bold; }
    .stat-label { font-size: 12px; opacity: 0.9; }
    .yes-stat { background: rgba(52, 211, 153, 0.3); padding: 8px; border-radius: 8px; }
    .no-stat { background: rgba(239, 68, 68, 0.3); padding: 8px; border-radius: 8px; }
    .empty-message { text-align: center; margin: 40px 0; color: #999; }
    .back-link { display: inline-block; margin: 20px 0; }
  </style>
</head>
<!-- R-Graph Feature: Insert at end of results.html (before </body>) -->
<style>
  /* R-Graph mini-styles */
  #rgraphWrap { max-width:900px; margin:20px auto 60px; font-family: Inter, system-ui, sans-serif; z-index:12; position:relative; }
  #rgraphHeader { display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom:8px; }
  #rgraphTitle { font-size:1.05rem; font-weight:700; color: #111827; }
  #rgraphCanvas { background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:12px; padding:14px; border:1px solid rgba(0,0,0,0.04); }
  .rgraph-controls { display:flex; gap:8px; align-items:center; }
  .rgraph-btn { padding:8px 12px; border-radius:10px; border:0; cursor:pointer; font-weight:600; background:linear-gradient(90deg,#7c3aed,#06b6d4); color:#fff; }
  .rgraph-secondary { background:#fff; color:#111; border:1px solid rgba(0,0,0,0.06); }
  #rgraphSVG { width:100%; height:360px; display:block; }
  #rgraphLegend { margin-top:8px; display:flex; gap:12px; align-items:center; }
  .legend-item { display:flex; gap:8px; align-items:center; font-size:13px; color:#374151; }
  .legend-swatch { width:14px;height:14px;border-radius:3px; }
  #rgraphRcode { margin-top:12px; background:#0b1220; color:#d1e8ff; padding:12px; border-radius:8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; font-size:13px; white-space:pre; }
  @media (max-width:720px) { #rgraphSVG { height:260px } }
</style>

<div id="rgraphWrap" aria-live="polite">
  <div id="rgraphHeader">
    <div>
      <div id="rgraphTitle">R Graph ‚Äî Yes / No counts per question</div>
      <div id="rgraphLegend">
        <div class="legend-item"><span class="legend-swatch" style="background:#60a5fa"></span>Yes</div>
        <div class="legend-item"><span class="legend-swatch" style="background:#fb7185"></span>No</div>
      </div>
    </div>
    <div class="rgraph-controls">
      <button id="rgraphRefresh" class="rgraph-btn">Refresh Chart</button>
      <button id="rgraphDownload" class="rgraph-btn rgraph-secondary">Download PNG</button>
    </div>
  </div>

  <div id="rgraphCanvas">
    <!-- SVG chart will be injected here -->
    <svg id="rgraphSVG" viewBox="0 0 900 360" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Bar chart of yes/no counts"></svg>
    <!-- R code block for reproducing the chart in R (ggplot2) -->
    <div id="rgraphRcode" aria-hidden="false"></div>
  </div>
</div>

<script>
(function () {
  // Utility: parse localStorage tracking_... entries (reuses your logic)
  function loadResults() {
    const results = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (!key || !key.startsWith('tracking_')) continue;
      try {
        const data = JSON.parse(localStorage.getItem(key));
        if (data && (data.sender || data.question)) results.push(data);
      } catch (e) { /* ignore */ }
    }
    return results;
  }

  // Build dataset: for each question produce {label, yes, no, total}
  function buildDataset(results) {
    return results.map((r, idx) => {
      const answers = Array.isArray(r.answers) ? r.answers.map(a => String(a.answer || '').toLowerCase()) : [];
      const yes = answers.filter(v => v === 'yes' || v === 'y' || v === 'true').length;
      const no = answers.filter(v => v === 'no' || v === 'n' || v === 'false').length;
      const label = (r.question || `Question ${idx+1}`).slice(0, 36); // short label
      return { label, yes, no, total: yes + no, fullLabel: r.question || `Question ${idx+1}` };
    });
  }

  // SVG chart drawing (grouped bar chart)
  function drawChart(dataset) {
    const svg = document.getElementById('rgraphSVG');
    // clear
    while (svg.firstChild) svg.removeChild(svg.firstChild);

    const width = 900, height = 360;
    const margin = { top: 28, right: 20, bottom: 90, left: 56 };
    const innerW = width - margin.left - margin.right;
    const innerH = height - margin.top - margin.bottom;

    // scales
    const n = dataset.length || 1;
    const groupWidth = innerW / Math.max(n,1);
    // find max count among yes/no totals to scale y
    const maxVal = Math.max(1, ...dataset.flatMap(d => [d.yes, d.no]));

    // helper to create SVG elements
    function el(tag, attrs = {}) {
      const e = document.createElementNS('http://www.w3.org/2000/svg', tag);
      for (const k in attrs) e.setAttribute(k, attrs[k]);
      return e;
    }

    // background
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

    // y axis lines + labels
    const axisG = el('g', { transform: `translate(${margin.left},${margin.top})` });
    const ticks = 5;
    for (let i = 0; i <= ticks; i++) {
      const y = innerH - (i / ticks) * innerH;
      const val = Math.round((i / ticks) * maxVal);
      // grid line
      axisG.appendChild(el('line', { x1: 0, y1: y, x2: innerW, y2: y, stroke: 'rgba(0,0,0,0.06)', 'stroke-width': 1 }));
      // label
      const lbl = el('text', { x: -12, y: y+4, 'text-anchor': 'end', 'font-size': 11, fill: '#374151' });
      lbl.textContent = val;
      axisG.appendChild(lbl);
    }
    svg.appendChild(axisG);

    // bars group
    const barsG = el('g', { transform: `translate(${margin.left},${margin.top})` });

    // for accessibility: axis labels
    const xAxis = el('text', { x: margin.left + innerW/2, y: height - 8, 'text-anchor': 'middle', 'font-size': 12, fill: '#374151' });
    xAxis.textContent = 'Questions';
    svg.appendChild(xAxis);

    // draw each group
    dataset.forEach((d, i) => {
      const gx = i * groupWidth;
      const groupPadding = Math.min(12, groupWidth * 0.18);
      const barW = Math.max(6, (groupWidth - groupPadding*2) / 2 - 6); // two bars per group

      // yes bar
      const yesH = (d.yes / Math.max(maxVal,1)) * innerH;
      const yesX = gx + groupPadding + 8;
      const yesY = innerH - yesH;
      const yesRect = el('rect', {
        x: yesX,
        y: yesY,
        width: Math.max(4, barW),
        height: Math.max(2, yesH),
        rx: 4, fill: '#60a5fa'
      });
      // tooltip-ish: title element
      const yesTitle = el('title'); yesTitle.textContent = `Yes: ${d.yes}`;
      yesRect.appendChild(yesTitle);
      barsG.appendChild(yesRect);

      // no bar
      const noH = (d.no / Math.max(maxVal,1)) * innerH;
      const noX = yesX + barW + 8;
      const noY = innerH - noH;
      const noRect = el('rect', {
        x: noX,
        y: noY,
        width: Math.max(4, barW),
        height: Math.max(2, noH),
        rx: 4, fill: '#fb7185'
      });
      const noTitle = el('title'); noTitle.textContent = `No: ${d.no}`;
      noRect.appendChild(noTitle);
      barsG.appendChild(noRect);

      // label (rotated or wrapped)
      const lblX = gx + groupWidth/2;
      const lbl = el('text', { x: lblX, y: innerH + 18, 'text-anchor': 'middle', 'font-size': 11, fill: '#374151' });
      // short label below, with full label on title attribute
      lbl.textContent = d.label.length > 18 ? d.label.slice(0,18) + '‚Ä¶' : d.label;
      const lblTitle = el('title'); lblTitle.textContent = d.fullLabel;
      lbl.appendChild(lblTitle);
      barsG.appendChild(lbl);
    });

    svg.appendChild(barsG);

    // small Y label
    const yAxisLabel = el('text', { x: 14, y: margin.top - 6, 'font-size': 12, fill: '#374151' });
    yAxisLabel.textContent = 'Count';
    svg.appendChild(yAxisLabel);
  }

  // Build R ggplot2 code to reproduce the chart
  function buildRCode(dataset) {
    // Build a small data.frame in R
    // e.g.
    // df <- data.frame(
    //   question = c("q1", "q2"),
    //   yes = c(3,1),
    //   no = c(2,4)
    // )
    // library(tidyr); library(ggplot2)
    // df_long <- pivot_longer(df, cols = c(yes,no), names_to='answer', values_to='count')
    // ggplot(df_long, aes(x=question, y=count, fill=answer)) + geom_col(position='dodge') + theme_minimal()

    const lines = [];
    lines.push('# Reproducible R (ggplot2) code ‚Äî copy & run in R');
    lines.push('library(ggplot2)');
    lines.push('library(tidyr)');
    lines.push('');
    // data.frame
    const qstrings = dataset.map(d => `"${d.fullLabel.replace(/"/g, '\\"')}"`);
    const yesvals = dataset.map(d => d.yes);
    const novals = dataset.map(d => d.no);
    lines.push('df <- data.frame(');
    lines.push('  question = c(' + qstrings.join(', ') + '),');
    lines.push('  yes = c(' + yesvals.join(', ') + '),');
    lines.push('  no = c(' + novals.join(', ') + ')');
    lines.push(')');
    lines.push('');
    lines.push('df_long <- pivot_longer(df, cols = c(yes, no), names_to = "answer", values_to = "count")');
    lines.push('');
    lines.push('ggplot(df_long, aes(x = question, y = count, fill = answer)) +');
    lines.push('  geom_col(position = position_dodge(width = 0.8), width = 0.7) +');
    lines.push('  scale_fill_manual(values = c(yes = "#60A5FA", no = "#FB7185")) +');
    lines.push('  theme_minimal() +');
    lines.push('  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +');
    lines.push('  labs(title = "Yes / No counts per question", x = "Question", y = "Count")');
    return lines.join('\\n');
  }

  // Update chart and R code block
  function updateGraph() {
    const results = loadResults();
    const data = buildDataset(results);
    // if no data, produce placeholder single entry
    const dataset = data.length ? data : [{ label: 'No data', yes: 0, no: 0, fullLabel: 'No tracked questions' }];
    drawChart(dataset);
    const code = buildRCode(dataset);
    const codeBlock = document.getElementById('rgraphRcode');
    codeBlock.textContent = code;
  }

  // Download PNG from SVG
  function downloadSVGAsPNG(filename = 'yesno_chart.png') {
    const svg = document.getElementById('rgraphSVG');
    const serializer = new XMLSerializer();
    const svgStr = serializer.serializeToString(svg);
    const canvas = document.createElement('canvas');
    const rect = svg.getBoundingClientRect();
    // set canvas size to exported size
    canvas.width = rect.width * 2; // higher DPI
    canvas.height = rect.height * 2;
    const ctx = canvas.getContext('2d');
    const img = new Image();
    const svgBlob = new Blob([svgStr], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(svgBlob);
    img.onload = function () {
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0,0,canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      URL.revokeObjectURL(url);
      canvas.toBlob(function (blob) {
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        URL.revokeObjectURL(link.href);
      }, 'image/png');
    };
    img.onerror = function (e) {
      console.error('SVG to PNG error', e);
      alert('Unable to export image in this browser.');
      URL.revokeObjectURL(url);
    };
    img.src = url;
  }

  // Wire up controls
  document.getElementById('rgraphRefresh').addEventListener('click', updateGraph);
  document.getElementById('rgraphDownload').addEventListener('click', () => downloadSVGAsPNG());

  // Auto-render on load and whenever results change (watch localStorage via storage event and a short poll)
  updateGraph();

  // If results updated in same tab (your setInterval displayResults), also refresh chart periodically
  const poll = setInterval(updateGraph, 3500);

  // Also refresh when other tabs change localStorage
  window.addEventListener('storage', (e) => {
    if (e.key && e.key.startsWith('tracking_')) updateGraph();
  });

  // Clean up if needed: stop polling when user navigates away
  window.addEventListener('beforeunload', () => clearInterval(poll));
})();
</script>

<body>
  <div class="page center-viewport">
    <div class="card fade-in">
      <h1>üìä Your Question Results üìä</h1>
      <p class="hint">Check the answers to your questions below:</p>
      
      <div id="resultsList" class="results-container">
        <div class="empty-message">Loading your questions...</div>
      </div>

      <div class="back-link" style="text-align: center;">
        <a href="index.html" class="btn primary">Create Another Question ‚ûï</a>
      </div>
    </div>
  </div>

  <script>
    function displayResults() {
      const resultsList = document.getElementById('resultsList');
      const results = [];

      // Scan localStorage for all tracked questions
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('tracking_')) {
          try {
            const data = JSON.parse(localStorage.getItem(key));
            if (data.sender || data.question) {
              results.push(data);
            }
          } catch (e) { }
        }
      }

      if (results.length === 0) {
        resultsList.innerHTML = '<div class="empty-message">No questions tracked yet.<br><br>Create a question and share it to see results! üéØ</div>';
        return;
      }

      // Render each question with answer counts
      let html = '';
      results.forEach((result, idx) => {
        const yesCount = (result.answers || []).filter(a => a.answer === 'yes').length;
        const noCount = (result.answers || []).filter(a => a.answer === 'no').length;
        const total = yesCount + noCount;

        html += `
          <div class="result-card">
            <div class="result-header">${result.sender || 'Anonymous'}</div>
            <div class="result-question">‚ùì ${result.question || 'Question'}</div>
            <div class="result-stats">
              <div class="stat yes-stat">
                <div class="stat-value">‚úÖ ${yesCount}</div>
                <div class="stat-label">Yes</div>
              </div>
              <div class="stat no-stat">
                <div class="stat-value">‚ùå ${noCount}</div>
                <div class="stat-label">No</div>
              </div>
              <div class="stat" style="background: rgba(168, 85, 247, 0.2); padding: 8px; border-radius: 8px;">
                <div class="stat-value">${total}</div>
                <div class="stat-label">Total</div>
              </div>
            </div>
          </div>
        `;
      });

      resultsList.innerHTML = html;
    }

    // Display results on page load
    displayResults();

    // Refresh results every 3 seconds (so sender can see live updates)
    setInterval(displayResults, 3000);
  </script>
</body>
</html>
